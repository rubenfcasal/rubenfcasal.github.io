<!DOCTYPE html>
<html lang="es">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.27" />
  <meta name="author" content="Ruben Fernandez-Casal">
  <meta name="description" content="Associate Professor (Contratado Doctor) of Statistics and Operational Research (Estadística e Investigación Operativa)">

  
  
  
  
    
  
  
    
    
    <link rel="stylesheet" href="/css/highlight.min.css">
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.1/css/academicons.min.css" integrity="sha512-NThgw3XKQ1absAahW6to7Ey42uycrVvfNfyjqcFNgCmOCQ5AR4AO0SiXrN+8ZtYeappp56lk1WtvjVmEa+VR6A==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  


  

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700%7cRoboto:400,400italic,700%7cRoboto&#43;Mono">
  
  <link rel="stylesheet" href="/styles.css">
  

  

  <link rel="alternate" href="" type="application/rss+xml" title="R Machinery">
  <link rel="feed" href="" type="application/rss+xml" title="R Machinery">

  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/apple-touch-icon.png">

  <link rel="canonical" href="/post/geoestadistica-no-parametrica-con-el-paquete-npsp/">

  

  <title>Geoestadística no paramétrica con el paquete *npsp* | R Machinery</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Barra de navegación</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
      <a class="navbar-brand" href="/"><img src="/img/rmach.png" alt="R Machinery"></a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/post">
            
            <span>Blog</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="https://rubenfcasal.github.io/npsp">
            
            <span>npsp</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>CV</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#contact">
            
            <span>Contacto</span>
          </a>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <h1 itemprop="name">Geoestadística no paramétrica con el paquete *npsp*</h1>
    

<div class="article-metadata">

  <span class="article-date">
    
    <time datetime="2018-02-15 00:00:00 &#43;0000 UTC" itemprop="datePublished">
      2018-02-15
    </time>
  </span>

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    18 
  </span>
  

  
  
  <span class="middot-divider"></span>
  <a href="/post/geoestadistica-no-parametrica-con-el-paquete-npsp/#disqus_thread"></a>
  

  
  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fa fa-folder"></i>
    
    <a href="/categories/apuntes">Apuntes</a
    >, 
    
    <a href="/categories/r">R</a
    >
    
  </span>
  
  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=Geoestad%c3%adstica%20no%20param%c3%a9trica%20con%20el%20paquete%20%2anpsp%2a&amp;url=%2fpost%2fgeoestadistica-no-parametrica-con-el-paquete-npsp%2f"
         target="_blank">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=%2fpost%2fgeoestadistica-no-parametrica-con-el-paquete-npsp%2f"
         target="_blank">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fpost%2fgeoestadistica-no-parametrica-con-el-paquete-npsp%2f&amp;title=Geoestad%c3%adstica%20no%20param%c3%a9trica%20con%20el%20paquete%20%2anpsp%2a"
         target="_blank">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=%2fpost%2fgeoestadistica-no-parametrica-con-el-paquete-npsp%2f&amp;title=Geoestad%c3%adstica%20no%20param%c3%a9trica%20con%20el%20paquete%20%2anpsp%2a"
         target="_blank">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=Geoestad%c3%adstica%20no%20param%c3%a9trica%20con%20el%20paquete%20%2anpsp%2a&amp;body=%2fpost%2fgeoestadistica-no-parametrica-con-el-paquete-npsp%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>

    <div class="article-style" itemprop="articleBody">
      <div id="TOC">
<ul>
<li><a href="#geoestadistica-no-parametrica">Geoestadística no paramétrica</a><ul>
<li><a href="#ejemplo">Ejemplo</a></li>
<li><a href="#modelo-general">Modelo general</a></li>
<li><a href="#ejemplo-1">Ejemplo</a></li>
<li><a href="#inferencia-no-parametrica-en-procesos-geoestadisticos">Inferencia (no paramétrica) en procesos geoestadísticos</a></li>
</ul></li>
<li><a href="#binning-lineal">Binning lineal</a><ul>
<li><a href="#discretizacion">Discretización</a></li>
<li><a href="#interpolacion">Interpolación</a></li>
</ul></li>
<li><a href="#estimacion-de-la-densidad">Estimación de la densidad</a></li>
<li><a href="#estimacion-de-la-tendencia">Estimación de la tendencia</a><ul>
<li><a href="#regresion-polinomica-local">Regresión polinómica local</a></li>
<li><a href="#implementacion-en-el-paquete-npsp">Implementación en el paquete <code>npsp</code></a></li>
<li><a href="#ejemplo-2">Ejemplo</a></li>
</ul></li>
<li><a href="#estimacion-del-variograma">Estimación del variograma</a><ul>
<li><a href="#estimacion-piloto-del-variograma">Estimación piloto del variograma</a></li>
<li><a href="#estimacion-piloto-del-variograma-con-correccion-de-sesgo">Estimación piloto del variograma con corrección de sesgo</a></li>
<li><a href="#ajuste-de-un-modelo-no-parametrico">Ajuste de un modelo no paramétrico</a></li>
</ul></li>
<li><a href="#seleccion-de-las-ventanas">Selección de las ventanas</a><ul>
<li><a href="#estimacion-de-la-tendencia-1">Estimación de la tendencia</a></li>
<li><a href="#estimacion-del-variograma-1">Estimación del variograma</a></li>
</ul></li>
<li><a href="#estimacion-conjunta-automatica">Estimación conjunta (automática)</a></li>
<li><a href="#prediccion-kriging">Predicción kriging</a></li>
<li><a href="#futuras-implementaciones">Futuras implementaciones</a></li>
<li><a href="#referencias">Referencias</a></li>
</ul>
</div>

<pre class="r"><code>library(npsp)</code></pre>
<pre><code>##  Package npsp: Nonparametric Spatial Statistics,
##  version 0.7-1 (built on 2018-02-11).
##  Copyright (C) R. Fernandez-Casal 2012-2018.
##  Type `help(npsp)` for an overview of the package and
##  `demo(package = &quot;npsp&quot;)` for the list of available demos.</code></pre>
<div id="geoestadistica-no-parametrica" class="section level1">
<h1>Geoestadística no paramétrica</h1>
<p>Nos centraremos en el caso de procesos espaciales <span class="math inline">\(\left\lbrace Y(\mathbf{x}), \mathbf{x} \in D\subset \mathbb{R}^{d} \right\rbrace\)</span>, con dominio <span class="math inline">\(D\)</span> continuo fijo: proceso geoestadístico.</p>
<ul>
<li>El objetivo en el futuro es considerar procesos puntuales marcados: <span class="math inline">\(D\)</span> es un proceso puntual en <span class="math inline">\(\mathbb{R}^{d}.\)</span></li>
</ul>
<p>Normalmente sólo se observa un conjunto de valores <span class="math inline">\(\left\{ y(\mathbf{x}_{1}),\ldots,y(\mathbf{x}_{n})\right\}\)</span> (<strong>realización parcial</strong>).</p>
<div id="ejemplo" class="section level2">
<h2>Ejemplo</h2>
<p>Se utilizará como ejemplo el conjunto de datos <a href="https://rubenfcasal.github.io/npsp/reference/aquifer.html"><code>aquifer</code></a>: nivel del agua subterránea en el acuífero Wolfcamp.</p>
<pre class="r"><code>str(aquifer)</code></pre>
<pre><code>## &#39;data.frame&#39;:    85 obs. of  3 variables:
##  $ lon : num  42.78 -27.4 -1.16 -18.62 96.47 ...
##  $ lat : num  127.6 90.8 84.9 76.5 64.6 ...
##  $ head: num  1464 2553 2158 2455 1756 ...</code></pre>
<pre class="r"><code>#   Scatter plot with a color scale
with(aquifer, spoints(lon, lat, head, main = &quot;Wolfcamp aquifer data&quot;))</code></pre>
<p><img src="/post/2018-02-15-geoestadística-no-paramétrica-con-el-paquete-npsp_files/figure-html/unnamed-chunk-2-1.png" width="576" /></p>
</div>
<div id="modelo-general" class="section level2">
<h2>Modelo general</h2>
<p>Se supone que el proceso se descompone en <em>variabilidad de gran escala</em> y <em>variabilidad de pequeña escala</em>: <span class="math display">\[Y(\mathbf{x})=\mu(\mathbf{x})+\varepsilon(\mathbf{x}),\]</span> donde:</p>
<ul>
<li><p><span class="math inline">\(\mu(\cdot)\)</span> es la tendencia (función determinística).</p></li>
<li><p><span class="math inline">\(\varepsilon(\cdot)\)</span> es un proceso de error estacionario de segundo orden, de media cero y covariograma: <span class="math display">\[C(\mathbf{u}) = Cov(\varepsilon(\mathbf{x}),
   \varepsilon(\mathbf{x}+\mathbf{u} ))\]</span> (varianza <span class="math inline">\(\sigma^2 = C(\mathbf{0})\)</span>).</p></li>
</ul>
<p>La dependencia espacial se modela normalmente a través del variograma: <span class="math display">\[2\gamma(\mathbf{u}) = Var(\varepsilon \left( \mathbf{x}\right)
-\varepsilon \left(\mathbf{x}+\mathbf{u}\right) ),\]</span> verificando <span class="math inline">\(\gamma(\mathbf{u}) = C(0) - C(\mathbf{u})\)</span>.</p>
<p>Se empleará un modelo <strong>no paramétrico</strong>: no se supone ninguna forma concreta para <span class="math inline">\(\mu(\mathbf{\cdot})\)</span> y <span class="math inline">\(\gamma(\mathbf{\cdot})\)</span> (funciones suaves).</p>
<ul>
<li><p>Evitan problemas debidos a una mala especificación del modelo.</p></li>
<li><p>Más fáciles de automatizar.</p></li>
<li><p>Resultan también de utilidad en inferencia paramétrica.</p></li>
</ul>
</div>
<div id="ejemplo-1" class="section level2">
<h2>Ejemplo</h2>
<p>Con el conjunto de datos de ejemplo puede ser preferible emplear métodos paramétricos. El tamaño muestral es pequeño y un modelo lineal para la tendencia parece ser adecuado.</p>
<pre class="r"><code>x &lt;- aquifer[,1:2]      # coordenadas espaciales
y &lt;- aquifer$head/100   # respuesta (en cientos de pies)
scattersplot(x, y, main = &quot;Wolfcamp aquifer data&quot;, xlab = &#39;lon&#39;, ylab =&#39;lat&#39;, 
             zlab = &#39;piezometric-head&#39;, col = jet.colors(128))</code></pre>
<p><img src="/post/2018-02-15-geoestadística-no-paramétrica-con-el-paquete-npsp_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
</div>
<div id="inferencia-no-parametrica-en-procesos-geoestadisticos" class="section level2">
<h2>Inferencia (no paramétrica) en procesos geoestadísticos</h2>
<p>A partir de los valores observados <span class="math inline">\(\mathbf{Y}=(Y(\mathbf{x}_1),\ldots,Y(\mathbf{x}_n))^{t}\)</span> puede interesar:</p>
<ul>
<li><p>Obtener predicciones (kriging): <span class="math inline">\(\hat{Y}(\mathbf{x}_0)\)</span>.</p></li>
<li><p>Realizar inferencias (estimación, contrastes) sobre las componentes del modelo <span class="math inline">\(\hat{\mu}(\cdot)\)</span>, <span class="math inline">\(\hat{\gamma}(\cdot)\)</span>.</p></li>
<li><p>Obtención de mapas de riesgo <span class="math inline">\(P({Y}(\mathbf{x}_0)\geq c)\)</span></p></li>
<li><p>…</p></li>
</ul>
<p>Aunque hay una gran cantidad de paquetes de R con herramientas de utilidad en geoestadística (<code>geoR</code>, <code>gstat</code>, <code>fields</code>, …) o en estadística no paramétrica (<code>mgcv</code>, <code>KernSmooth</code>, <code>sm</code>, …), la mayoría presentan una funcionalidad muy limitada para estadística espacial no paramétrica o resulta difícil emplearlos para implementar nuevos métodos (además de otras limitaciones, como su eficiencia computacional o el número de dimensiones que soportan). Por este motivo se decidió desarrollar el paquete <a href="https://rubenfcasal.github.io/npsp"><code>npsp</code></a>:</p>
<ul>
<li><p>CRAN: <a href="https://cran.r-project.org/package=npsp" class="uri">https://cran.r-project.org/package=npsp</a></p></li>
<li><p>Github: <a href="http://github.com/rubenfcasal/npsp" class="uri">http://github.com/rubenfcasal/npsp</a></p></li>
</ul>
<p>La idea sería:</p>
<ul>
<li><p>Proporcionar un entorno homogéneo para la estimación polinómica lócal multidimensional (tendencia, variograma, densidad, …), especialmente para el caso de procesos espaciales (y espacio-temporales).</p></li>
<li><p>Trata de minimizar el tiempo de computación y los requerimientos de memoria.</p></li>
<li><p>Emplear clases y métodos S3 sencillos (que permitan interactuar con las clases S4 del paquete <code>sp</code> y las nuevas S3 del paquete <code>sf</code>; ver <code>npsp/inst/</code> <a href="https://github.com/rubenfcasal/npsp/blob/master/inst/locpol_classes.pdf">locpol_classes.pdf</a>).</p></li>
<li><p>Robusto y que facilite la implementación de nuevos métodos.</p></li>
</ul>
</div>
</div>
<div id="binning-lineal" class="section level1">
<h1>Binning lineal</h1>
<p>Para acelerar los cálculos se emplea binning (WARPing; e.g. Wand and Jones, 1995):</p>
<ul>
<li>datos <span class="math inline">\(\Longrightarrow\)</span> discretización <span class="math inline">\(\Longrightarrow\)</span> suavizado <span class="math inline">\(\Longrightarrow\)</span> interpolación</li>
</ul>
<p>Normalmente el resultado final del análisis es una rejilla y el último paso sólo interesa en cálculos intermedios (e.g. obtención de residuos).</p>
<div id="discretizacion" class="section level2">
<h2>Discretización</h2>
<p>En la estimación polinómica local se emplea binning lineal.</p>
<ul>
<li>Wand M.P. and Jones M.C. (1995) <em>Kernel Smoothing</em>. Chapman and Hall.</li>
</ul>
<p>Las principales funciones son:</p>
<ul>
<li><p>Tendencia (y densidad): <a href="https://rubenfcasal.github.io/npsp/reference/binning.html"><code>binning</code></a>.</p></li>
<li><p>Variograma: <a href="https://rubenfcasal.github.io/npsp/reference/svar.bin.html"><code>svar.bin</code></a></p></li>
</ul>
<p>Normalmente se emplearan dos rejillas, una de baja resolución para acelerar los cálculos durante el proceso de modelado (selección de la ventana, cálculos intermedios, …) y otra con la resolución deseada para obtener los resultados finales.</p>
<pre class="r"><code>cpu.time(reset=TRUE)</code></pre>
<pre><code>## CPU time has been initialized.</code></pre>
<pre class="r"><code>bin &lt;- binning(x, y, nbin = c(41,41), set.NA = TRUE) 
simage(bin, main = &#39;Binning averages&#39;)
# Data points
points(bin$data$x, col = &#39;darkgray&#39;)
# Binning grid
coordvs &lt;- coordvalues(bin)
abline(v = coordvs[[1]], lty = 3)
abline(h = coordvs[[2]], lty = 3)</code></pre>
<p><img src="/post/2018-02-15-geoestadística-no-paramétrica-con-el-paquete-npsp_files/figure-html/binning-1.png" width="576" /></p>
<pre class="r"><code>cpu.time(total = FALSE)</code></pre>
<pre><code>## Time of last operation: 
##    user  system elapsed 
##    0.03    0.00    0.03</code></pre>
</div>
<div id="interpolacion" class="section level2">
<h2>Interpolación</h2>
<p>En el paquete se emplea interpolación lineal (algoritmo análogo al binning lineal). Métodos:</p>
<ul>
<li><a href="https://rubenfcasal.github.io/npsp/reference/interp.html"><code>interp</code></a> y <a href="https://rubenfcasal.github.io/npsp/reference/interp.html"><code>predict</code></a></li>
</ul>
</div>
</div>
<div id="estimacion-de-la-densidad" class="section level1">
<h1>Estimación de la densidad</h1>
<p>La estimación de la densidad está implementada como un caso particular de regresión (se suavizan los pesos binning reescalados):</p>
<ul>
<li><a href="https://rubenfcasal.github.io/npsp/reference/np.den.html"><code>np.den</code></a>.</li>
</ul>
<p>Por defecto emplea el estimador lineal local (establecer <code>degree = 0</code> para Nadaraya-Watson).</p>
<pre class="r"><code>den &lt;- np.den(bin, h = diag(60, 2), degree = 0) 
# alternatively, set h = h.cv(as.bin.den(bin))$h
plot(den, main = &#39;Estimated log(density)&#39;)</code></pre>
<p><img src="/post/2018-02-15-geoestadística-no-paramétrica-con-el-paquete-npsp_files/figure-html/np.den-1.png" width="576" /></p>
<p>Se puede emplear por ejemplo para establecer una máscara que filtre las posiciones alejadas de los datos.</p>
<pre class="r"><code>bin &lt;- mask(bin, mask = log(den$est) &gt; -14)
str(bin)</code></pre>
<pre><code>## List of 5
##  $ biny: num [1:41, 1:41] NA NA NA NA NA NA 35.1 35.1 NA NA ...
##  $ binw: num [1:41, 1:41] 0 0 0 0 0 ...
##  $ grid:List of 6
##   ..$ nd      : int 2
##   ..$ n       : int [1:2] 41 41
##   ..$ min     : num [1:2] -145.24 9.41
##   ..$ max     : num [1:2] 113 185
##   ..$ lag     : num [1:2] 6.45 4.38
##   ..$ dimnames: chr [1:2] &quot;lon&quot; &quot;lat&quot;
##   ..- attr(*, &quot;class&quot;)= chr &quot;grid.par&quot;
##  $ data:List of 3
##   ..$ x  : num [1:85, 1:2] 42.78 -27.4 -1.16 -18.62 96.47 ...
##   .. ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. .. ..$ : chr [1:85] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
##   .. .. ..$ : chr [1:2] &quot;lon&quot; &quot;lat&quot;
##   ..$ y  : num [1:85] 14.6 25.5 21.6 24.6 17.6 ...
##   ..$ med: num 20
##  $ mask: logi [1:41, 1:41] TRUE TRUE TRUE TRUE TRUE TRUE ...
##  - attr(*, &quot;class&quot;)= chr [1:3] &quot;bin.data&quot; &quot;bin.den&quot; &quot;data.grid&quot;</code></pre>
<pre class="r"><code>cpu.time(total = FALSE)</code></pre>
<pre><code>## Time of last operation: 
##    user  system elapsed 
##     0.2     0.1     0.3</code></pre>
</div>
<div id="estimacion-de-la-tendencia" class="section level1">
<h1>Estimación de la tendencia</h1>
<div id="regresion-polinomica-local" class="section level2">
<h2>Regresión polinómica local</h2>
<p>En el caso univariante, para cada <span class="math inline">\(x_{0}\)</span> se ajusta un polinomio: <span class="math display">\[\beta_{0}+\beta_{1}\left(x - x_{0}\right) + \cdots 
+ \beta_{p}\left( x-x_{0}\right)^{p}\]</span> por mínimos cuadrados ponderados, con pesos <span class="math inline">\(w_{i} = \frac{1}{h}K\left(\frac{x-x_{0}}{h}\right)\)</span>.</p>
<ul>
<li><p>La estimación en <span class="math inline">\(x_{0}\)</span> es <span class="math inline">\(\hat{\mu}_{h}(x_{0})=\hat{\beta}_{0}\)</span>.</p></li>
<li><p>Adicionalmente: <span class="math inline">\(\widehat{\mu_{h}^{r)}}(x_{0}) = r!\hat{\beta}_{r}\)</span>.</p></li>
</ul>
<p>Habitualmente se considera:</p>
<ul>
<li><p><span class="math inline">\(p=0\)</span>: Estimador Nadaraya-Watson.</p></li>
<li><p><span class="math inline">\(p=1\)</span>: Estimador lineal local.</p></li>
</ul>
<p>El caso multivariante es análogo. La estimación lineal local multivariante <span class="math inline">\(\hat{\mu}_{\mathbf{H}}(\mathbf{x})=\hat{\beta}_{0}\)</span> se obtiene al minimizar: <span class="math display">\[\min_{\beta_{0},\boldsymbol{\beta}_{1}}\sum_{i=1}^{n}
\left( Y(\mathbf{x}_{i})-\beta_{0}-{\boldsymbol{\beta}}_{1}^{t}
(\mathbf{x}_{i}-\mathbf{x})\right)^{2}
K_{\mathbf{H}}(\mathbf{x}_{i}-\mathbf{x}),\]</span> donde:</p>
<ul>
<li><p><span class="math inline">\(\mathbf{H}\)</span> es la matriz de ventanas <span class="math inline">\(d\times d\)</span> (simétrica no singular).</p></li>
<li><p><span class="math inline">\(K_{\mathbf{H}}(\mathbf{u})=\left\vert \mathbf{H}\right\vert ^{-1}K(\mathbf{H}^{-1}\mathbf{u})\)</span> y <span class="math inline">\(K\)</span> núcleo multivariante.</p></li>
</ul>
<p>Explícitamente: <span class="math display">\[\hat{\mu}_{\mathbf{H}}(\mathbf{x}) = \mathbf{e}_{1}^{t} \left(
\mathbf{X}_{\mathbf{x}}^{t} {\mathbf{W}}_{\mathbf{x}} 
\mathbf{X}_{\mathbf{x}} \right)^{-1} \mathbf{X}_{\mathbf{x}}^{t} 
{\mathbf{W}}_{\mathbf{x}}\mathbf{Y} \equiv {s}_{\mathbf{x}}^{t}\mathbf{Y},\]</span> donde <span class="math inline">\(\mathbf{e}_{1} = \left( 1, \cdots, 0\right)^{t}\)</span>, <span class="math inline">\(\mathbf{X}_{\mathbf{x}}\)</span> es la matriz con <span class="math inline">\((1,(\mathbf{x}_{i}-\mathbf{x})^{t})\)</span> en fila <span class="math inline">\(i\)</span>, y <span class="math inline">\(\mathbf{W}_{\mathbf{x}} = \mathtt{diag} \left( K_{\mathbf{H}}(\mathbf{x}_{1} - \mathbf{x}), ..., K_{\mathbf{H}}(\mathbf{x}_{n}-\mathbf{x}) \right)\)</span> es la matriz de pesos.</p>
<p>Se puede pensar que se obtiene aplicando un suavizado lineal a <span class="math inline">\((\mathbf{x}_i, Y(\mathbf{x}_i))\)</span>: <span class="math display">\[\hat{\boldsymbol{\mu}} = \mathbf{SY},\]</span> siendo <span class="math inline">\(\mathbf{S}\)</span> la matriz de suavizado con <span class="math inline">\(\mathbf{s}_{\mathbf{x}_{i}}^{t}\)</span> en la fila <span class="math inline">\(i\)</span>.</p>
</div>
<div id="implementacion-en-el-paquete-npsp" class="section level2">
<h2>Implementación en el paquete <code>npsp</code></h2>
<p>La estimación polinómica local está implementada en la función genérica <a href="https://rubenfcasal.github.io/npsp/reference/locpol.html"><code>locpol</code></a>:</p>
<ul>
<li><p>Emplea una matriz de ventanas completa y un núcleo triweight para el cálculo de los pesos.</p></li>
<li><p>Permite cálcular eficientemente la matriz de suavizado <span class="math inline">\(\mathbf{S}\)</span> (de utilidad en la estimación de la dependencia, en la selección de la ventana, …).</p></li>
<li><p>Código <em>optimizado</em> para minimizar el tiempo de computación y los requerimientos de memoria (especialmente para validación cruzada, estimación del variograma, …). Los cálculos se realizan en FORTRAN.</p></li>
<li><p>Para resolver el problema de regresión lineal (local), se emplea (<a href="https://github.com/rubenfcasal/npsp/blob/master/src/dgelsyr.f"><code>src/dgelsyr.f</code></a>) una modificación de la rutina DGELSY de la librería LAPACK (admite matrices de rango deficiente).</p></li>
</ul>
</div>
<div id="ejemplo-2" class="section level2">
<h2>Ejemplo</h2>
<pre class="r"><code>lp &lt;- locpol(bin, h = diag(100, 2), hat.bin = TRUE)  
# Perspective plot with a color scale
spersp(lp, main = &#39;Trend estimates&#39;, zlab = &#39;piezometric-head&#39;, theta = 120)   </code></pre>
<p><img src="/post/2018-02-15-geoestadística-no-paramétrica-con-el-paquete-npsp_files/figure-html/unnamed-chunk-6-1.png" width="576" /></p>
<pre class="r"><code>cpu.time(total = FALSE)</code></pre>
<pre><code>## Time of last operation: 
##    user  system elapsed 
##    0.22    0.04    0.26</code></pre>
</div>
</div>
<div id="estimacion-del-variograma" class="section level1">
<h1>Estimación del variograma</h1>
<p>Al igual que en la geoestadística paramétrica tradicional, el modelado de la dependencia se realiza a partir de los residuos: <span class="math display">\[e(\mathbf{x}_{i})=Y(\mathbf{x}_{i})-\hat{\mu}(\mathbf{x}_{i}).\]</span> Si la media se supone cte. (proceso estacionario) se trabaja directamente con las observaciones (se sustituiría <span class="math inline">\(e(\mathbf{x}_{i})\)</span> por <span class="math inline">\(Y(\mathbf{x}_{i})\)</span> en las expresiones).</p>
<p>La estimación se realiza en dos pasos, en primer lugar se obtiene una estimación piloto del variograma y posteriormente se ajusta un modelo válido.</p>
<div id="estimacion-piloto-del-variograma" class="section level2">
<h2>Estimación piloto del variograma</h2>
<p>En los métodos tradicionales se trata como un caso particular de regresión: <span class="math display">\[\gamma\left(  \mathbf{x}_{i}-\mathbf{x}_{j}\right)  =\frac{1}{2}E\left(
\varepsilon(\mathbf{x}_{i})-\varepsilon(\mathbf{x}_{j})\right)^{2}\]</span> con <span class="math inline">\(N=\frac{n(n-1)}{2}\)</span> observaciones: <span class="math display">\[{\left(\mathbf{x}_{i}-\mathbf{x}_{j},
(e(\mathbf{x}_{i})-e(\mathbf{x}_{j}))^2 / 2 \right)},\]</span> asumiendo que la variabilidad de los residuos es (similar a) la de los errores.</p>
<p>La estimación polinómico local <span class="math inline">\(\hat{\gamma}_{\mathbf{G}}(\mathbf{u}) = \hat{\beta}_{0}\)</span> se obtendría minimizando: <span class="math display">\[\begin{aligned}
\min_{\beta_{0}, \boldsymbol{\beta}_{1}, \cdots}
\sum_{i=1}^{n}\left( \frac{1}{2} \left( e(\mathbf{x}_{i})-e(\mathbf{x}_{j})
\right)^{2} - \beta_{0} - {\boldsymbol{\beta}}_{1}^{t} (\mathbf{x}_{i} - 
\mathbf{x}_{j} - \mathbf{u}) - \cdots\right)  ^{2}\times &amp; \\
K_{\mathbf{G}}(\mathbf{x}_{i}-\mathbf{x}_{j}-\mathbf{u})  &amp;
\end{aligned},\]</span> siendo <span class="math inline">\(\mathbf{G}\)</span> la correspondiente matriz de ventanas.</p>
<p>Actualmente en el paquete <code>npsp</code> solo está implementado el caso isotrópico:</p>
<ul>
<li><p><a href="https://rubenfcasal.github.io/npsp/reference/svar.bin.html"><code>svar.bin</code></a>: estimador empírico con binning lineal.</p></li>
<li><p><a href="https://rubenfcasal.github.io/npsp/reference/np.svar.html"><code>np.svar</code></a>: estimador polinómico local.</p></li>
</ul>
<p>Estas funciones son adecuadas para procesos estacionarios y se podrían emplear en el caso no estacionario para estimar el variograma residual (sesgado) calculando previamente los residuos.</p>
<pre class="r"><code>lp.resid &lt;- residuals(lp)
esvar0 &lt;- np.svariso(x, lp.resid, nlags = 50, h = 50)
plot(esvar0, main = &quot;Nonparametric (residual) pilot semivariogram&quot;)</code></pre>
<p><img src="/post/2018-02-15-geoestadística-no-paramétrica-con-el-paquete-npsp_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<pre class="r"><code>cpu.time(total = FALSE)</code></pre>
<pre><code>## Time of last operation: 
##    user  system elapsed 
##    0.11    0.04    0.14</code></pre>
</div>
<div id="estimacion-piloto-del-variograma-con-correccion-de-sesgo" class="section level2">
<h2>Estimación piloto del variograma con corrección de sesgo</h2>
<p>El uso directo de los residuos <span class="math inline">\(\boldsymbol{\hat{\varepsilon}} = \mathbf{Y} - \hat{\boldsymbol{\mu}} = (\mathbf{I - S})\mathbf{Y}\)</span> introduce un sesgo en la estimación del variograma, ya que su variabilidad es distinta de la de los errores: <span class="math display">\[Var(\boldsymbol{\hat{\varepsilon}}) = 
{\boldsymbol{\Sigma}}_{\hat{\varepsilon}}
= \boldsymbol{\Sigma} + \mathbf{B},\]</span> siendo <span class="math inline">\(\mathbf{B} = \mathbf{S} \boldsymbol{\Sigma} \mathbf{S}^{t} - \boldsymbol{\Sigma} \mathbf{S}^{t} - \mathbf{S} \boldsymbol{\Sigma}\)</span> la matriz de sesgos.</p>
<p>En términos del variograma: <span class="math display">\[Var\left(\hat{\varepsilon}(\mathbf{x}_i) 
- \hat{\varepsilon}(\mathbf{x}_j) \right) =
Var\left(\varepsilon(\mathbf{x}_i) - \varepsilon(\mathbf{x}_j) \right)
+ b_{ii} + b_{jj} - 2 b_{ij}.\]</span> Este sesgo es normalmente negativo y mayor en saltos grandes (ver p.e. Cressie, 1993, sección 3.4.3). En Fernandez-Casal y Francisco-Fernandez (2013) se propone un método iterativo para su corrección. La función <code>np.svariso.corr</code> implementa un algoritmo similar (totalmente no paramétrico). Comenzando con el estimador lineal local residual anterior, en cada iteración <span class="math inline">\(k\)</span> se actualizan las diferencias <span class="math inline">\((\hat{\varepsilon}(\mathbf{x}_i)- \hat{\varepsilon}(\mathbf{x}_j))^2\)</span> reemplazándolas por: <span class="math display">\[(\hat{\varepsilon}(\mathbf{x}_i)- \hat{\varepsilon}(\mathbf{x}_j))^2 
- \hat{b}_{ii}^{(k-1)} - \hat{b}_{jj}^{(k-1)} + 2 \hat{b}_{ij}^{(k-1)},\]</span> siendo <span class="math inline">\(\hat{\mathbf{B}}^{(k-1)}\)</span> la aproximación del sesgo obtenida en la iteración anterior.</p>
<p>Ejemplo:</p>
<pre class="r"><code>esvar &lt;- np.svariso.corr(lp, nlags = 50, h = 50, plot = TRUE)</code></pre>
<p><img src="/post/2018-02-15-geoestadística-no-paramétrica-con-el-paquete-npsp_files/figure-html/np.svariso.corr-1.png" width="672" /></p>
<pre><code>## Iteration  2 :  1 
## Iteration  3 :  0.1071746 
## Iteration  4 :  0.07731208 
## Iteration  5 :  0.06118289 
## Iteration  6 :  0.05087295 
## Iteration  7 :  0.04358588</code></pre>
<pre class="r"><code>cpu.time(total = FALSE)</code></pre>
<pre><code>## Time of last operation: 
##    user  system elapsed 
##    0.27    0.01    0.28</code></pre>
</div>
<div id="ajuste-de-un-modelo-no-parametrico" class="section level2">
<h2>Ajuste de un modelo no paramétrico</h2>
<p>Los estimadores piloto no verifican las propiedades de un variograma (condicionalmente semidefinidos negativos) y no pueden ser usados en predicción espacial (kriging). Para resolver este problema se ajusta un modelo válido.</p>
<p>La función <a href="https://rubenfcasal.github.io/npsp/reference/fitsvar.sb.iso.html"><code>fitsvar.sb.iso</code></a> permite ajustar un modelo no paramétrico de Shapiro-Botha. En el caso isotrópico son de la forma: <span class="math display">\[\gamma(\left\Vert \mathbf{u} \right\Vert ) = \nu_{0} - 
    \sum\limits_{k=1}^{K}\kappa_{d}(x_{k}\left\Vert \mathbf{u}\right\Vert )
    z_{k},\]</span> siendo:</p>
<ul>
<li><p><span class="math inline">\(\kappa_{d}(x) = \left( \tfrac{2}{x}\right)^{{\frac{d{-2}}{2}}} \Gamma\left( \tfrac{d}{2}\right) J_{{\frac{d{-2}}{2}}}(x)\)</span>, donde <span class="math inline">\(J_p\)</span> es la función de Bessel de orden <span class="math inline">\(p\)</span>.</p></li>
<li><p><span class="math inline">\(x_{k}\)</span> nodos de discretización (siguiendo la recomendación de Gorsich y Genton, 2004, se establecen reescalando los ceros de las funciones de Bessel (ver <a href="https://rubenfcasal.github.io/npsp/reference/disc.sb.html"><code>disc.sb</code></a>).).</p></li>
<li><p><span class="math inline">\(\left( z_{1}, ..., z_{K}, \nu_{0} \right)^{t}\)</span> parámetros, verificando: <span class="math display">\[z_{k} \geq0 \text{ y } 
c_{0} =  \nu_{0}-\sum\nolimits_{k=1}^{K}z_{k}\geq0.\]</span></p></li>
</ul>
<p>El ajuste por WLS a un conjunto de estimaciones piloto se puede realizar fácilmente mediante programación cuadrática (modificación de la función <code>solve.QP</code> del paquete <code>quadprog</code> para obtener la solución de problemas no estrictamente convexos).</p>
<p>Estos modelos son muy flexibles por lo que es habitual considerar una dimensión <span class="math inline">\(d\)</span> mayor que la de los datos para obtener ajustes más suaves (empleando el parámetro <code>dk</code>). En el límite obtendríamos <span class="math inline">\(\kappa_{\infty}(x)\equiv e^{-x^{2}}\)</span>, que se correspondería con un modelo válido en cualquier dimensión (se selecciona estableciendo<code>dk = 0</code>).</p>
<p>Ejemplo:</p>
<pre class="r"><code>svm &lt;- fitsvar.sb.iso(esvar, dk = 0)
plot(svm, main = &quot;Nonparametric semivariogram and fitted model&quot;)
svm0 &lt;- fitsvar.sb.iso(esvar0, dk = 0) 
with(svm0$fit, lines(u, fitted.sv, lty = 3, lwd = 2))</code></pre>
<p><img src="/post/2018-02-15-geoestadística-no-paramétrica-con-el-paquete-npsp_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<pre class="r"><code>cpu.time(total = FALSE)</code></pre>
<pre><code>## Time of last operation: 
##    user  system elapsed 
##    0.15    0.03    0.19</code></pre>
<p>Estos modelos son extensibles al caso anisotrópico (Fernandez-Casal <em>et al</em>., 2003), adecuado para procesos espacio-temporales.</p>
</div>
</div>
<div id="seleccion-de-las-ventanas" class="section level1">
<h1>Selección de las ventanas</h1>
<p>La función genérica <a href="https://rubenfcasal.github.io/npsp/reference/h.cv.html"><code>h.cv</code></a> permite seleccionar la ventana de una estimación polinómico local (de la tendencia, densidad o variograma) usando criterios de validación cruzada (CV), validación cruzada generalizada (GCV) o MASE (estándar y modificados).</p>
<div id="estimacion-de-la-tendencia-1" class="section level2">
<h2>Estimación de la tendencia</h2>
<p>Con los criterios de selección de la ventana diseñados para datos independientes se tiende a infrasuavizar la estimación (e.g. Opsomer et al, 2001):</p>
<ul>
<li><p>Validación cruzada tradicional (LOOCV): <span class="math display">\[CV(\mathbf{H})=\frac{1}{n}\sum_{i=1}^{n}
\left( Y(\mathbf{x}_{i}) - \hat{\mu}_{-i}(\mathbf{x}_{i}) \right)^{2},\]</span> siendo <span class="math inline">\(\hat{\mu}_{-i}(\mathbf{x}_{i})\)</span> la estimación obtenida eliminando el dato <span class="math inline">\(i\)</span>-ésimo.</p></li>
<li><p>Validación cruzada generalizada (Craven y Wahba, 1978): <span class="math display">\[GCV(\mathbf{H})=\frac{1}{n}\sum_{i=1}^{n}
\left(  \frac{Y(\mathbf{x}_{i}) -\hat{\mu}(\mathbf{x}_{i})}
{1-\frac{1}{n}tr\left( \mathbf{S}\right) }\right)^{2}.\]</span></p></li>
</ul>
<p>Por ello se han propuesto distintos criterios alternativos para el caso de datos dependientes:</p>
<ul>
<li><p>Validación cruzada modificada (Chu and Marron, 1991): <span class="math display">\[MCV(\mathbf{H})=\frac{1}{n}\sum_{i=1}^{n}\left(  Y(\mathbf{x}_{i})-\hat
{\mu}_{-N(i)}(\mathbf{x}_{i})\right)^{2},\]</span> siendo <span class="math inline">\(\hat{\mu}_{-i}(\mathbf{x}_{i})\)</span> la estimación obtenida eliminando los datos en un vecindario <span class="math inline">\(N(i)\)</span> de <span class="math inline">\(\mathbf{x}_{i}\)</span>.</p></li>
<li><p>Validación cruzada generalizada con corrección de sesgo para dependencia (Francisco-Fernandez and Opsomer, 2005): <span class="math display">\[CGCV(\mathbf{H})=\frac{1}{n}\sum_{i=1}^{n} \left(  
\frac{Y(\mathbf{x}_{i}) -\hat{\mu}(\mathbf{x}_{i})} {1 -
\frac{1}{n}tr\left( \mathbf{S} \hat{\mathbf{R}} \right) }\right)^{2},\]</span> siendo <span class="math inline">\(\hat{\mathbf{R}}\)</span> una estimación de la matriz de correlaciones.</p></li>
</ul>
<p>Adicionalmente, reescribiendo el criterio MCV de la forma: <span class="math display">\[MCV(\mathbf{H}) = \frac{1}{n}  \left( \mathbf{Y}-\mathbf{S}_{-N} \mathbf{Y}\right) ^{t} \left( \mathbf{Y}-\mathbf{S}_{-N} \mathbf{Y} \right),\]</span> donde <span class="math inline">\(N = \left\lbrace N(1),\ldots, N(n) \right\rbrace\)</span>, puede verse que: <span class="math display">\[\mathrm{E}\left( MCV(\mathbf{H})\right) \simeq MASE(\mathbf{H}) +
\sigma^{2} - \frac{2}{n}tr\left(\mathbf{S}_{-N}\boldsymbol{\Sigma}\right),\]</span> siendo: <span class="math display">\[MASE(\mathbf{H})= \frac{1}{n}\mathbb{E}\left( \left(
\mathbf{SY}-\boldsymbol{\mu}\right)^{t} \left(
\mathbf{SY}-\boldsymbol{\mu}\right) \right) = \\
= \frac{1}{n}\left(\mathbf{S}\boldsymbol{\mu}-\boldsymbol{\mu}\right)^{t}
\left( \mathbf{S}\boldsymbol{\mu}-\boldsymbol{\mu}\right) +
\frac{1}{n}tr\left( \mathbf{S}\boldsymbol{\Sigma }\mathbf{S}^{t}\right).\]</span></p>
<ul>
<li><p>Validación cruzada modificada corregida (Fernández-Casal et al, Preprint): <span class="math display">\[CMCV(\mathbf{H}) = \frac{1}{n}\sum_{i=1}^{n} \left( 
Y(\mathbf{x}_{i}) - \hat{\mu}_{-N(i)}{(\mathbf{x_i)}} \right)^{2} + 
\frac{2}{n}tr\left( \mathbf{S}_{-N} \hat{\boldsymbol{\Sigma}}\right).\]</span> <span class="math inline">\(CCV\)</span> sería un caso particular tomando <span class="math inline">\(N = N_1 = \left\lbrace \{\mathbf{x}_{1}\}, \ldots, \{\mathbf{x}_{n}\}\right\rbrace\)</span>.</p></li>
<li><p>Ventana por bootstrap suavizado: El criterio <span class="math inline">\(MASE(\mathbf{H})\)</span> puede ser empleado cuando se conocen la media y varianzas teóricas (p.e. en simulación), pero si se sustituyen por estimaciones, obtendríamos la ventana óptima MASE de la correspondiente distribución bootstrap.</p></li>
</ul>
<pre class="r"><code>#   Example:
bin2 &lt;- binning(x, y)     # sets nbin automatically
h.cv(bin2, h.start = c(100, 100))                # MCV (ncv = 2)</code></pre>
<pre><code>## $h
##          [,1]   [,2]
## [1,] 150.2659  0.000
## [2,]   0.0000 82.392
## 
## $value
## [1] 3.989047
## 
## $objective
## [1] &quot;CV&quot;</code></pre>
<pre class="r"><code># cov.bin &lt;-  varcov(svm2, coords = coords(bin2))
lp.h &lt;- h.cv(bin2, cov.bin = svm, h.start = c(100, 100)) # CMCV (ncv = 2)
lp.h</code></pre>
<pre><code>## $h
##          [,1]     [,2]
## [1,] 403.1891   0.0000
## [2,]   0.0000 206.8383
## 
## $value
## [1] 5.948936
## 
## $objective
## [1] &quot;CV&quot;</code></pre>
<pre class="r"><code>cpu.time(total = FALSE)</code></pre>
<pre><code>## Time of last operation: 
##    user  system elapsed 
##    1.11    0.25    1.36</code></pre>
<p>Hay que tener cuidado con los algoritmos de optimización automáticos. Por defecto se emplea el método “L-BFGS-B” de la función <code>optim</code>. Como se trata de una minimización no lineal multidimensional puede haber problemas de mínimos locales. Para intentar evitar este problema se puede establecer unos valores iniciales para los parámetros de la ventana mediante el argumento <code>h.start</code>. Alternativamente se puede establecer el parámetro <code>DEalgorithm = TRUE</code> para utilizar el algoritmo genético de optimización del paquete <code>DEoptim</code> (aunque puede aumentar considerablemente el tiempo de computación).</p>
<p>Empleando la ventana seleccionada se podría reestimar de nuevo la tendencia, aunque también habría que volver a estimar el variograma (si se modifica la variabilidad de gran escala, habría que actualizar la variabilidad de pequeña escala). Este procedimento se podría repetir iterativamente. Se tratará más adelante en la sección “<a href="Estimación%20conjunta%20(automática)">Estimación conjunta (automática)</a>”.</p>
</div>
<div id="estimacion-del-variograma-1" class="section level2">
<h2>Estimación del variograma</h2>
<p>La ventana para la estimación del variograma puede seleccionarse por ejemplo minimizando el correspondiente error cuadrático de validación cruzada: <span class="math display">\[\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n}
\left( \left( \hat{\varepsilon}(\mathbf{x}_{i})
- \hat{\varepsilon}(\mathbf{x}_{j})\right)^{2}
- 2\hat{\gamma}_{-(i,j)}\left( \left\Vert \mathbf{x}_{i}
- \mathbf{x}_{j}\right\Vert \right) \right) ^{2},\]</span> siendo <span class="math inline">\(\hat{\gamma}_{-(i,j)}(\cdot )\)</span> la estimación obtenida descartando <span class="math inline">\(\left( \hat{\varepsilon}(\mathbf{x}_{i}) - \hat{\varepsilon}(\mathbf{x}_{j})\right) ^{2}\)</span>. Sin embargo, para tener un mejor ajuste cerca del origen, suele ser preferible emplear el error cuadrático relativo de validación cruzada: <span class="math display">\[\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n}\left( \frac{\left( \hat{
\varepsilon}(\mathbf{x}_{i})-\hat{\varepsilon}(\mathbf{x}_{j})\right) ^{2}
}{2\hat{\gamma}_{-(i,j)}\left( \left\Vert \mathbf{x}_{i}-\mathbf{x}
_{j}\right\Vert \right) }-1\right) ^{2}.\]</span> Adicionalmente, si hay datos atípicos, sería recomendable emplear un error absoluto en lugar de cuadrático.</p>
<p>Ninguno de estos criterios tiene en cuenta la dependencia entre las semivarianzas, por lo que las ventanas seleccionadas tenderán a infrasuavizar (especialmente en saltos grandes). Si se emplea un procedimiento automático, puede ser recomendable incrementar la ventana obtenida con estos criterios (en el algoritmo automático implementado en <code>np.fitgeo</code> descrito a continuación, si no se especifica la ventana para la estimación del variograma, se incrementa por defecto la ventana obtenida con <code>h.cv</code> en un 50%).</p>
<p>NOTA: Actualmente sólo está implementada la estimación con ventana global. En este caso, como las semivarianzas no son homocedásticas, sería preferible emplear ventanas locales.</p>
</div>
</div>
<div id="estimacion-conjunta-automatica" class="section level1">
<h1>Estimación conjunta (automática)</h1>
<p>Como se comentó en la sección anterior, para poder seleccionar una ventana “óptima” para la estimación de la tendencia es necesario disponer de una estimación del variograma. Sin embargo, la estimación de la dependencia requiere de una estimación de la tendencia. Para resolver este problema circular se puede emplear un algoritmo iterativo (similar al método de estimación paramétrica tradicional propuesto por Neuman y Jacobson, 1984):</p>
<ol style="list-style-type: decimal">
<li><p>Seleccionar una ventana inicial <span class="math inline">\(\mathbf{H}^{(0)}\)</span> para <span class="math inline">\(\hat{\mu}\)</span> (usando por ejemplo <span class="math inline">\(MCV\)</span>).</p></li>
<li><p>Para <span class="math inline">\(k\geq 1\)</span>, usando la ventana <span class="math inline">\(\mathbf{H}^{(k-1)}\)</span> calcular <span class="math inline">\(\hat{\boldsymbol{\mu}} = \mathbf{S}\mathbf{Y}\)</span> y los correspondientes residuos <span class="math inline">\(\hat{\boldsymbol{\varepsilon}}\)</span>.</p></li>
<li><p>Empleando el algoritmo para la corrección de sesgo, obtener una estimación piloto <span class="math inline">\(\tilde{\gamma}(\cdot)\)</span>, y ajustar un modelo S-B.</p></li>
<li><p>Construir <span class="math inline">\(\hat{\Sigma}^{(k)}\)</span> y seleccionar una nueva ventana <span class="math inline">\(\mathbf{H}^{(k)}\)</span> (empleando <span class="math inline">\(CMCV\)</span> o <span class="math inline">\(CGCV\)</span>).</p></li>
<li><p>Repetir los pasos 2 al 4 hasta obtener convergencia.</p></li>
</ol>
<p>Este algoritmo está implementado en la función <a href="https://rubenfcasal.github.io/npsp/reference/np.fitgeo.html">np.fitgeo</a> y normalmente dos iteraciones (el valor por defecto) son suficientes. Por ejemplo, se podría hacer un modelado automático ejecutando:</p>
<pre class="r"><code>geom &lt;- np.fitgeo(x, y, svm.resid = TRUE, h.start = c(100, 100))
cpu.time(total = FALSE)</code></pre>
<pre><code>## Time of last operation: 
##    user  system elapsed 
##    0.95    0.22    1.17</code></pre>
<p>El parámetro <code>iter</code> controla el número máximo de iteraciones del algoritmo completo. Estableciendo <code>iter = 0</code> se emplea el variograma residual:</p>
<pre class="r"><code>geom0 &lt;- np.fitgeo(x, y, iter = 0, h.start = c(100, 100))</code></pre>
<p>La rutina devuelve el modelo no paramétrico ajustado, un objeto <a href="https://rubenfcasal.github.io/npsp/reference/np.geo.html">np.geo</a> que contiene las estimaciones de la tendencia y del variograma. Al representarlo gráficamente:</p>
<pre class="r"><code>plot(geom)</code></pre>
<p><img src="/post/2018-02-15-geoestadística-no-paramétrica-con-el-paquete-npsp_files/figure-html/plot.np.fitgeo-1.png" width="672" /> Además de las estimaciones finales de la tendencia y del variograma, se muestra también el variograma ajustado obtenido en la iteración anterior (y si <code>svm.resid = TRUE</code> el variograma residual). Si no hay grandes diferencias no habría necesidad de seguir iterando, ya que el criterio de selección de la ventana proporcionaría un suavizado similar.</p>
</div>
<div id="prediccion-kriging" class="section level1">
<h1>Predicción kriging</h1>
<p>La función genérica <code>kriging.np</code> permite obtener predicciones mediante kriging residual (combinando la estimación de la tendencia con el kriging simple de los residuos). Actualmente solo está implementado kriging simple y kriging residual con vecindario global. Para la resolución del sistema de ecuaciones kriging, a partir de la factorización de Choleski de la matriz de covarianzas, se emplea el paquete <code>spam</code> para matrices dispersas.</p>
<p>Como ejemplo, compararemos las predicciones kriging obtenidas con el ajuste automático con las correspondientes a la estimación con el variograma residual.</p>
<pre class="r"><code>krig.grid0 &lt;- kriging.np(geom0, ngrid = c(96, 96)) # 9216 predicciones
krig.grid &lt;- kriging.np(geom, ngrid = c(96, 96))
cpu.time(total = FALSE)</code></pre>
<pre><code>## Time of last operation: 
##    user  system elapsed 
##    3.01    0.09    3.10</code></pre>
<pre class="r"><code>old.par &lt;- par(mfrow = c(1,2), omd = c(0.01, 0.9, 0.05, 0.95))
scale.range &lt;- range(krig.grid0$trend, krig.grid$trend, finite = TRUE)
simage( krig.grid0, &#39;trend&#39;, slim = scale.range, 
        main = &#39;Trend estimates (residuals)&#39;, col = jet.colors(256), legend = FALSE)
simage( krig.grid, &#39;trend&#39;, slim = scale.range, 
        main = &#39;Trend estimates (iteration 2)&#39;, col = jet.colors(256), legend = FALSE)
par(old.par)
splot(slim = scale.range, col = jet.colors(256), add = TRUE)</code></pre>
<p><img src="/post/2018-02-15-geoestadística-no-paramétrica-con-el-paquete-npsp_files/figure-html/unnamed-chunk-9-1.png" width="864" /></p>
<pre class="r"><code>old.par &lt;- par(mfrow = c(1,2), omd = c(0.01, 0.9, 0.05, 0.95))
scale.range &lt;- range(krig.grid0$kpred, krig.grid$kpred, finite = TRUE)
simage( krig.grid0, &#39;kpred&#39;, slim = scale.range, 
       main = &#39;Kriging predictions (residuals)&#39;, col = jet.colors(256), 
       legend = FALSE)
simage( krig.grid, &#39;kpred&#39;, slim = scale.range, 
       main = &#39;Kriging predictions (iteration 2)&#39;, col = jet.colors(256), 
       legend = FALSE)
par(old.par)
splot(slim = scale.range, col = jet.colors(256), add = TRUE)</code></pre>
<p><img src="/post/2018-02-15-geoestadística-no-paramétrica-con-el-paquete-npsp_files/figure-html/unnamed-chunk-9-2.png" width="864" /></p>
<p>Hay que tener en cuenta que se trata de un método robusto y no depende demasiado del modelo de tendencia (la variabilidad no explicada por la tendencia es capturada por la variabilidad de pequeña escala). En este caso es de especial importancia la estimación del variograma cerca del origen.</p>
<p>Sin embargo, si se comparan las varianzas kriging (o se emplean otros métodos de inferencia, como por ejemplo bootstrap) puede haber grandes diferencias entre los resultados obtenidos con distintos modelos.</p>
<pre class="r"><code>old.par &lt;- par(mfrow = c(1,2), omd = c(0.01, 0.9, 0.05, 0.95))
simage( krig.grid0, &#39;ksd&#39;, slim = scale.range, 
        main = &#39;Kriging sd (residuals)&#39;, col = hot.colors(256), legend = FALSE)
with(aquifer, points(lon, lat, cex = 0.75))
simage( krig.grid, &#39;ksd&#39;, slim = scale.range, 
        main = &#39;Kriging sd (iteration 2)&#39;, col = hot.colors(256), legend = FALSE)
with(aquifer, points(lon, lat, cex = 0.75))
par(old.par)
splot(slim = scale.range, col = hot.colors(256), add = TRUE)</code></pre>
<p><img src="/post/2018-02-15-geoestadística-no-paramétrica-con-el-paquete-npsp_files/figure-html/unnamed-chunk-10-1.png" width="864" /></p>
<pre class="r"><code>cpu.time()</code></pre>
<pre><code>## Time of last operation: 
##    user  system elapsed 
##    0.33    0.13    0.45 
## Total time:
##    user  system elapsed 
##    6.38    0.91    7.28</code></pre>
</div>
<div id="futuras-implementaciones" class="section level1">
<h1>Futuras implementaciones</h1>
<ul>
<li><p>Modelos anisotrópicos de semivariograma (caso espacio-temporal).</p></li>
<li><p>Modelos aditivos y parcialmente lineales.</p></li>
<li><p>Modelos dinámicos.</p></li>
<li><p>Kriging local.</p></li>
<li><p>…</p></li>
</ul>
</div>
<div id="referencias" class="section level1">
<h1>Referencias</h1>
<ul>
<li><p>Chu, C.K. and Marron, J.S. (1991) Comparison of Two Bandwidth Selectors with Dependent Errors. <em>The Annals of Statistics</em>, <strong>19</strong>, 1906-1918.</p></li>
<li><p>Fernández-Casal R., Castillo-Páez S. and Francisco-Fernández M. (2018), Nonparametric geostatistical risk mapping, <em>Stoch. Environ. Res. Ris. Assess.</em>, <a href="https://doi.org/10.1007/s00477-017-1407-y">DOI</a>.</p></li>
<li><p>Fernández-Casal R., Castillo-Páez S. and García-Soidán P. (2017), Nonparametric estimation of the small-scale variability of heteroscedastic spatial processes, <em>Spa. Sta.</em>, <strong>22</strong>, 358-370, <a href="https://doi.org/10.1016/j.spasta.2017.04.001">DOI</a>.</p></li>
<li><p>Fernandez-Casal R. and Francisco-Fernandez M. (2014) Nonparametric bias-corrected variogram estimation under non-constant trend, <em>Stoch. Environ. Res. Ris. Assess.</em>, <strong>28</strong>, 1247-1259.</p></li>
<li><p>Fernandez-Casal R., Gonzalez-Manteiga W. and Febrero-Bande M. (2003) Flexible Spatio-Temporal Stationary Variogram Models, <em>Statistics and Computing</em>, <strong>13</strong>, 127-136.</p></li>
<li><p>Francisco-Fernandez M. and Opsomer J.D. (2005) Smoothing parameter selection methods for nonparametric regression with spatially correlated errors. <em>Canadian Journal of Statistics</em>, 33, 539-558.</p></li>
<li><p>Rupert D. and Wand M.P. (1994) Multivariate locally weighted least squares regression. <em>The Annals of Statistics</em>, <strong>22</strong>, 1346-1370.</p></li>
<li><p>Shapiro A. and Botha J.D. (1991) Variogram fitting with a general class of conditionally non-negative definite functions. <em>Computational Statistics and Data Analysis</em>, <strong>11</strong>, 87-96.</p></li>
<li><p>Wand M.P. (1994) Fast Computation of Multivariate Kernel Estimators. <em>Journal of Computational and Graphical Statistics</em>, <strong>3</strong>, 433-445.</p></li>
<li><p>Wand M.P. and Jones M.C. (1995) <em>Kernel Smoothing</em>. Chapman and Hall, London.</p></li>
</ul>
</div>

    </div>

    
    
    
    <div class="article-tags">
      
      <a class="btn btn-primary btn-outline" href="/tags/geoestad%c3%adstica">Geoestadística</a>
      
      <a class="btn btn-primary btn-outline" href="/tags/regresion">regresion</a>
      
      <a class="btn btn-primary btn-outline" href="/tags/paquetes">Paquetes</a>
      
    </div>
    
    

  </div>

</article>



<div class="article-container article-widget">
  <div class="hr-light"></div>
  <h3></h3>
  <ul>
    
    <li><a href="/post/introducci%C3%B3n-a-la-geoestad%C3%ADstica-con-geor/">Introducción a la Geoestadística con `geoR`</a></li>
    
    <li><a href="/post/npsp/">Geoestadística no paramétrica con `npsp`</a></li>
    
    <li><a href="/post/diagnosis-de-la-independencia/">Diagnosis de la independencia</a></li>
    
    <li><a href="/post/2015-07-23-r-rmarkdown/">Hello R Markdown</a></li>
    
  </ul>
</div>




<div class="article-container">
  
<section id="comments">
  <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-rubenfcasal-github-io" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2017 Ruben Fernandez-Casal &middot; 

      Powered by <a href="https://bookdown.org/yihui/blogdown" target="_blank">blogdown</a> 
      and the <a href="https://github.com/gcushen/hugo-academic" target="_blank">Academic
      theme</a> for <a href="http://gohugo.io" target="_blank">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>

    

    
    
    <script id="dsq-count-scr" src="//https-rubenfcasal-github-io.disqus.com/count.js" async></script>
    

    
    <script async defer src="//maps.googleapis.com/maps/api/js"></script>
    

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha512-3P8rXCuGJdNZOnUx/03c1jOTnMn3rP63nBip5gOP2qmUh5YAdVAvFZ1E+QLZZbC1rtMrQb+mah3AfYW11RUrWA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.3/imagesloaded.pkgd.min.js" integrity="sha512-umsR78NN0D23AzgoZ11K7raBD+R6hqKojyBZs1w8WvYlsI+QuKRGBx3LFCwhatzBunCjDuJpDHwxD13sLMbpRA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gmaps.js/0.4.25/gmaps.min.js" integrity="sha256-7vjlAeb8OaTrCXZkCNun9djzuB2owUsaO72kXaFDBJs=" crossorigin="anonymous"></script>
    
    <script src="/js/hugo-academic.js"></script>
    

    
    
      
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
      

      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML" integrity="sha512-tOav5w1OjvsSJzePRtt2uQPFwBoHt1VZcUq8l8nm5284LEKE9FSJBQryzMBzHxY5P0zRdNqEcpLIRVYFNgu1jw==" crossorigin="anonymous"></script>
    
    

  </body>
</html>

