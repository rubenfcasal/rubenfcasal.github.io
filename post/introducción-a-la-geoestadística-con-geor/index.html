<!DOCTYPE html>
<html lang="es">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.30.2" />
  <meta name="author" content="Ruben Fernandez-Casal">
  <meta name="description" content="Associate Professor (Contratado Doctor) of Statistics and Operational Research (Estadística e Investigación Operativa)">

  
  
  
  
    
  
  
    
    
    <link rel="stylesheet" href="/css/highlight.min.css">
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.1/css/academicons.min.css" integrity="sha512-NThgw3XKQ1absAahW6to7Ey42uycrVvfNfyjqcFNgCmOCQ5AR4AO0SiXrN+8ZtYeappp56lk1WtvjVmEa+VR6A==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  


  

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700%7cRoboto:400,400italic,700%7cRoboto&#43;Mono">
  
  <link rel="stylesheet" href="/styles.css">
  

  

  <link rel="alternate" href="" type="application/rss+xml" title="R Machinery">
  <link rel="feed" href="" type="application/rss+xml" title="R Machinery">

  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/apple-touch-icon.png">

  <link rel="canonical" href="/post/introducci%C3%B3n-a-la-geoestad%C3%ADstica-con-geor/">

  

  <title>Introducción a la Geoestadística con `geoR` | R Machinery</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Barra de navegación</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
      <a class="navbar-brand" href="/"><img src="/img/rmach.png" alt="R Machinery"></a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/post">
            
            <span>Blog</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="https://rubenfcasal.github.io/npsp">
            
            <span>npsp</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>CV</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#contact">
            
            <span>Contacto</span>
          </a>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <h1 itemprop="name">Introducción a la Geoestadística con `geoR`</h1>
    

<div class="article-metadata">

  <span class="article-date">
    
    <time datetime="2017-10-23 00:00:00 &#43;0000 UTC" itemprop="datePublished">
      2017-10-23
    </time>
  </span>

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    18 
  </span>
  

  
  
  <span class="middot-divider"></span>
  <a href="/post/introducci%C3%B3n-a-la-geoestad%C3%ADstica-con-geor/#disqus_thread"></a>
  

  
  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fa fa-folder"></i>
    
    <a href="/categories/apuntes">Apuntes</a
    >, 
    
    <a href="/categories/r">R</a
    >
    
  </span>
  
  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=Introducci%c3%b3n%20a%20la%20Geoestad%c3%adstica%20con%20%60geoR%60&amp;url=%2fpost%2fintroducci%25C3%25B3n-a-la-geoestad%25C3%25ADstica-con-geor%2f"
         target="_blank">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=%2fpost%2fintroducci%25C3%25B3n-a-la-geoestad%25C3%25ADstica-con-geor%2f"
         target="_blank">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fpost%2fintroducci%25C3%25B3n-a-la-geoestad%25C3%25ADstica-con-geor%2f&amp;title=Introducci%c3%b3n%20a%20la%20Geoestad%c3%adstica%20con%20%60geoR%60"
         target="_blank">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=%2fpost%2fintroducci%25C3%25B3n-a-la-geoestad%25C3%25ADstica-con-geor%2f&amp;title=Introducci%c3%b3n%20a%20la%20Geoestad%c3%adstica%20con%20%60geoR%60"
         target="_blank">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=Introducci%c3%b3n%20a%20la%20Geoestad%c3%adstica%20con%20%60geoR%60&amp;body=%2fpost%2fintroducci%25C3%25B3n-a-la-geoestad%25C3%25ADstica-con-geor%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>

    <div class="article-style" itemprop="articleBody">
      <div id="TOC">
<ul>
<li><a href="#el-paquete-geor">El paquete <code>geoR</code></a><ul>
<li><a href="#inicio-de-una-sesion-y-de-carga-de-datos">1. Inicio de una sesión y de carga de datos</a><ul>
<li><a href="#cargar-el-paquete">1.1 Cargar el paquete</a></li>
<li><a href="#archivos-de-datos">1.2 Archivos de datos</a></li>
</ul></li>
<li><a href="#analisis-descriptivo-de-datos-geoestadisticos">2. Análisis descriptivo de datos geoestadísticos</a></li>
<li><a href="#modelado-de-la-dependencia">3. Modelado de la dependencia</a><ul>
<li><a href="#variogramas-empiricos">3.1 Variogramas empíricos</a></li>
<li><a href="#ajuste-de-un-modelo-de-variograma">3.2 Ajuste de un modelo de variograma</a></li>
<li><a href="#inferencia-sobre-el-variograma">3.3 Inferencia sobre el variograma</a></li>
<li><a href="#validacion-cruzada">3.4 Validación cruzada</a></li>
<li><a href="#estimacion-del-variograma-en-procesos-no-estacionarios">3.5 Estimación del variograma en procesos no estacionarios</a></li>
</ul></li>
<li><a href="#prediccion-espacial-kriging">4. Predicción espacial (kriging)</a></li>
</ul></li>
</ul>
</div>

<p><br></p>
<div id="el-paquete-geor" class="section level1">
<h1>El paquete <code>geoR</code></h1>
<p>El paquete <code>geoR</code> proporciona herramientas para el análisis de datos geoestadísticos en <code>R</code> (otra alternativa puede ser emplear el paquete <code>gstat</code>, por ejemplo…). A continuación se ilustran algunas de las capacidades de este paquete.</p>
<p><br></p>
<div id="inicio-de-una-sesion-y-de-carga-de-datos" class="section level2">
<h2>1. Inicio de una sesión y de carga de datos</h2>
<div id="cargar-el-paquete" class="section level3">
<h3>1.1 Cargar el paquete</h3>
<p>Después de iniciar la sesión R, cargar <code>geoR</code> con el comando <code>library</code> (o <code>require</code>). Si el paquete se carga correctamente aparece un mensaje.</p>
<pre class="r"><code>library(geoR)</code></pre>
<pre><code>   # --------------------------------------------------------------
   #  Analysis of Geostatistical Data
   #  For an Introduction to geoR go to http://www.leg.ufpr.br/geoR
   #  geoR version 1.7-5.2 (built on 2016-05-02) is now loaded
   # --------------------------------------------------------------</code></pre>
<p><br></p>
</div>
<div id="archivos-de-datos" class="section level3">
<h3>1.2 Archivos de datos</h3>
<p>Normalmente, los datos se almacenan como un objeto (una lista) de la clase <code>geodata</code>. Un objeto de esta clase contiene obligatoriamente dos elementos:</p>
<ul>
<li><p><code>$coords</code>: las coordenadas de las posiciones de los datos.</p></li>
<li><p><code>$data</code>: los valores observados de la variables.</p></li>
</ul>
<p>Opcionalmente pueden tener otros elementos, como covariables y coordenadas de las fronteras de la zona de estudio.</p>
<p>Hay algunos conjuntos de datos incluidos en el paquete de distribución.</p>
<pre class="r"><code># data()                    # lista todos los conjuntos de datos disponibles
# data(package = &quot;geoR&quot;)    # lista los conjuntos de datos en el paquete geoR

data(wolfcamp)              # carga el archivo de datos wolfcamp
summary(wolfcamp)</code></pre>
<pre><code>   # Number of data points: 85 
   # 
   # Coordinates summary
   #       Coord.X   Coord.Y
   # min -233.7217 -145.7884
   # max  181.5314  136.4061
   # 
   # Distance summary
   #         min         max 
   #   0.3669819 436.2067085 
   # 
   # Data summary
   #      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
   #  312.1095  471.8218  547.7156  610.2845  774.1778 1088.4209</code></pre>
<p>Se pueden importar directamente un archivo de datos en formato texto:</p>
<pre class="r"><code>ncep &lt;- read.geodata(&#39;ncep.txt&#39;, header = FALSE, coords.col = 1:2, data.col = 4)
# plot(ncep)
# summary(ncep)</code></pre>
<p>También se puede convertir un <code>data.frame</code> a un objeto <code>geodata</code>:</p>
<pre class="r"><code>ncep.df &lt;- read.table(&#39;ncep.txt&#39;, header = FALSE)
names(ncep.df) &lt;- c(&#39;x&#39;, &#39;y&#39;, &#39;t&#39;, &#39;z&#39;)
# str(ncep.df)
# Nota: los datos son espacio-temporales, pero geoR sólo admite datos 2D

datgeo &lt;- as.geodata(ncep.df, coords.col = 1:2, data.col = 4)
# plot(datgeo)
# summary(datgeo)</code></pre>
<p>O objetos de datos espaciales (entre ellos los compatibles del paquete <code>sp</code>), por ejemplo el siguiente código crea un objeto <code>SpatialPointsDataFrame</code> y lo convierte a <code>geodata</code>:</p>
<pre class="r"><code>library(sp)
load(&quot;caballa.galicia.RData&quot;)
coordinates(caballa.galicia) &lt;- c(&quot;x&quot;,&quot;y&quot;)
proj4string(caballa.galicia) &lt;- CRS(&quot;+proj=longlat +ellps=WGS84&quot;)

datgeo &lt;- as.geodata(caballa.galicia[&quot;lcpue&quot;])
# Problemas con coordenadas duplicadas  (ver ?duplicated)
# plot(datgeo)
# summary(datgeo)     </code></pre>
<p>En la documentación de las funciones <code>as.geodata</code> y <code>read.geodata</code> hay más información sobre cómo importar/convertir datos.</p>
<p><br></p>
</div>
</div>
<div id="analisis-descriptivo-de-datos-geoestadisticos" class="section level2">
<h2>2. Análisis descriptivo de datos geoestadísticos</h2>
<p>Como se mostró anteriormente, el método <code>summary</code> proporciona un breve resumen descriptivo de los datos (ver <code>?summary.geodata</code>).</p>
<p>La función <code>plot()</code> genera por defecto gráficos de los valores en las posiciones espaciales (distinguiendo según cuartiles), los datos frente a las coordenadas y un histograma de los datos:</p>
<pre class="r"><code>plot(wolfcamp)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-6-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Los gráficos de dispersión de los datos frente a las coordenadas nos pueden ayudar a determinar si hay una tendencia. También, en lugar del histograma, nos puede interesar un gráfico de dispersión 3D</p>
<pre class="r"><code>plot(wolfcamp, lowess = TRUE, scatter3d = TRUE) </code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Si se asume que hay una tendencia puede interesar eliminarla:</p>
<pre class="r"><code>plot(wolfcamp, trend=~coords)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-8-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>El comando <code>points(geodata)</code> (función <code>points.geodata</code>) genera un gráfico con las posiciones de los datos (y por defecto con el tamaño de los puntos proporcional al valor):</p>
<pre class="r"><code>points(wolfcamp)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-9-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Se pueden establecer los tamaños de los puntos, simbolos y colores a partir de los valores de los datos. Por ejemplo, para los puntos, empleando el argumento: <code>pt.divide = c(&quot;data.proportional&quot;, &quot;rank.proportional&quot;, &quot;quintiles&quot;,</code> <code>&quot;quartiles&quot;, &quot;deciles&quot;, &quot;equal&quot;)</code>.</p>
<pre class="r"><code>points(wolfcamp, col = &quot;gray&quot;, pt.divide = &quot;equal&quot;)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-10-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><br></p>
</div>
<div id="modelado-de-la-dependencia" class="section level2">
<h2>3. Modelado de la dependencia</h2>
<p>En la primera parte de esta sección consideraremos un proceso espacial sin tendencia:</p>
<pre class="r"><code>data(s100) # Cargar datos estacionarios
summary(s100)</code></pre>
<pre><code>   # Number of data points: 100 
   # 
   # Coordinates summary
   #         Coord.X    Coord.Y
   # min 0.005638006 0.01091027
   # max 0.983920544 0.99124979
   # 
   # Distance summary
   #         min         max 
   # 0.007640962 1.278175109 
   # 
   # Data summary
   #       Min.    1st Qu.     Median       Mean    3rd Qu.       Max. 
   # -1.1676955  0.2729882  1.1045936  0.9307179  1.6101707  2.8678969 
   # 
   # Other elements in the geodata object
   # [1] &quot;cov.model&quot; &quot;nugget&quot;    &quot;cov.pars&quot;  &quot;kappa&quot;     &quot;lambda&quot;</code></pre>
<pre class="r"><code>plot(s100)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-11-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>En el último apartado se tratará el caso general. <br></p>
<div id="variogramas-empiricos" class="section level3">
<h3>3.1 Variogramas empíricos</h3>
<p>Los variogramas empíricos se calculan utilizando la función <code>variog</code>:</p>
<pre class="r"><code>oldpar &lt;- par(mfrow=c(1,2)) 
plot(variog(s100))</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<pre class="r"><code>plot(variog(s100, max.dist = 0.6))</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-12-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>par(oldpar)</code></pre>
<p>La recomendación es considerar solo saltos hasta la mitad de la máxima distancia (ver ‘Distance summary’ en resultados del sumario).</p>
<pre class="r"><code>vario &lt;- variog(s100, max.dist = 0.6)</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<pre class="r"><code>names(vario)</code></pre>
<pre><code>   #  [1] &quot;u&quot;                &quot;v&quot;                &quot;n&quot;               
   #  [4] &quot;sd&quot;               &quot;bins.lim&quot;         &quot;ind.bin&quot;         
   #  [7] &quot;var.mark&quot;         &quot;beta.ols&quot;         &quot;output.type&quot;     
   # [10] &quot;max.dist&quot;         &quot;estimator.type&quot;   &quot;n.data&quot;          
   # [13] &quot;lambda&quot;           &quot;trend&quot;            &quot;pairs.min&quot;       
   # [16] &quot;nugget.tolerance&quot; &quot;direction&quot;        &quot;tolerance&quot;       
   # [19] &quot;uvec&quot;             &quot;call&quot;</code></pre>
<pre class="r"><code># str(vario)</code></pre>
<p>NOTA: La componente <code>u</code> contiene los saltos, <code>v</code> las estimaciones del semivariograma (semivarianzas) y <code>n</code> el número de aportaciones.</p>
<p>Los resultados pueden ser nubes de puntos (semivarianzas), valores discretizados (binned) o suavizados, dependiendo del parámetro: <code>option = c(&quot;bin&quot;, &quot;cloud&quot;, &quot;smooth&quot;)</code></p>
<pre class="r"><code># Calculo de los variogramas empíricos
vario.b &lt;- variog(s100, max.dist = 0.6) #discretizado</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<pre class="r"><code>vario.c &lt;- variog(s100, max.dist=0.6, op=&quot;cloud&quot;)  #nube</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<pre class="r"><code>vario.bc &lt;- variog(s100, max.dist=0.6, bin.cloud=TRUE)  #discretizado+nube</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<pre class="r"><code>vario.s &lt;- variog(s100, max.dist=0.6, op=&quot;sm&quot;, band=0.2)  #suavizado</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<pre class="r"><code># Representación gráfica
oldpar&lt;-par(mfrow=c(2,2)) # Preparar para 4 gráficos por ventana
plot(vario.b, main=&quot;Variograma empírico&quot;)
plot(vario.c, main=&quot;Nube de puntos variograma&quot;)
plot(vario.bc, bin.cloud=TRUE, main=&quot;Graficos de cajas&quot;)
title(&quot;Gráficos de cajas&quot;) # Corregir fallo del comando anterior
plot(vario.s, main=&quot;Variograma suavizado&quot;)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-14-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>par(oldpar) # Restaurar opciones de gráficos</code></pre>
<p>Si hay valores atípicos (o la distribución de los datos es asimétrica) puede ser preferible utilizar el estimador robusto. Se puede calcular este estimador estableciendo <code>estimator.type = &quot;modulus&quot;</code>:</p>
<pre class="r"><code>varior.b &lt;- variog(s100, estimator.type = &quot;modulus&quot;, max.dist=0.6)</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<pre class="r"><code>varior.bc &lt;- variog(s100, estimator.type = &quot;modulus&quot;, max.dist=0.6, bin.cloud=TRUE)</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<pre class="r"><code>oldpar&lt;-par(mfrow=c(2,2)) #Preparar para 4 gráficos por ventana
plot(vario.b, main=&quot;Estimador clásico&quot;)
plot(varior.b, main=&quot;Estimador robusto&quot;)
plot(vario.bc, bin.cloud=TRUE)
plot(varior.bc, bin.cloud=TRUE)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-15-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>par(oldpar) #Restaurar opciones de gráficos</code></pre>
<p>En el caso de anisotropía, también se pueden obtener variogramas direccionales con la función <code>variog</code> mediante los argumentos <code>direction</code> y <code>tolerance</code>. Por ejemplo, para calcular un variograma en la dirección de 60 grados (con la tolerancia angular por defecto de 22.5 grados):</p>
<pre class="r"><code>vario.60 &lt;- variog(s100, max.dist = 0.6, direction = pi/3) #variograma en la dirección de 60 grados</code></pre>
<pre><code>   # variog: computing variogram for direction = 60 degrees (1.047 radians)
   #         tolerance angle = 22.5 degrees (0.393 radians)</code></pre>
<p>Para estudiar si hay anisotropía, se pueden cálcular de forma rápida variogramas direccionales con la función <code>variog4</code>. Por defecto calcula cuatro variogramas direccionales, correspondientes a los ángulos 0, 45, 90 y 135 grados:</p>
<pre class="r"><code>vario.4 &lt;- variog4(s100, max.dist = 0.6)</code></pre>
<pre><code>   # variog: computing variogram for direction = 0 degrees (0 radians)
   #         tolerance angle = 22.5 degrees (0.393 radians)
   # variog: computing variogram for direction = 45 degrees (0.785 radians)
   #         tolerance angle = 22.5 degrees (0.393 radians)
   # variog: computing variogram for direction = 90 degrees (1.571 radians)
   #         tolerance angle = 22.5 degrees (0.393 radians)
   # variog: computing variogram for direction = 135 degrees (2.356 radians)
   #         tolerance angle = 22.5 degrees (0.393 radians)
   # variog: computing omnidirectional variogram</code></pre>
<pre class="r"><code>oldpar &lt;- par(mfrow=c(1,2))
plot(vario.60)
title(main = expression(paste(&quot;direccional, angulo = &quot;, 60 * degree)))
plot(vario.4, lwd = 2)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-17-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>par(oldpar)</code></pre>
<p><br></p>
</div>
<div id="ajuste-de-un-modelo-de-variograma" class="section level3">
<h3>3.2 Ajuste de un modelo de variograma</h3>
<p>Los estimadores empíricos no pueden ser empleados en la práctica (no verifican necesariamente las propiedades de un variograma válido), por lo que se suele recurrir en la práctica al ajuste de un modelo válido. Con el paquete <code>geoR</code> podemos realizar el ajuste:</p>
<ol style="list-style-type: decimal">
<li><p>“A ojo”: representando diferentes modelos sobre un variograma empírico (usando la función <code>lines.variomodel</code> o la función <code>eyefit</code>).</p></li>
<li><p>Por mínimos cuadrados: ajustando por mínimos cuadrados ordinarios (OSL) o ponderados (WLS) al variograma empírico (usando la función <code>variofit</code>),</p></li>
<li><p>Por máxima verosimilitud: estimando por máxima verosimilitud (ML) o máxima verosimilitud restringida (REML) los parámetros a partir de los datos (utilizando la función <code>likfit</code>),</p></li>
<li><p>Métodos bayesianos (utilizando la función <code>krige.bayes</code>).</p></li>
</ol>
<p>Ejemplo de ajuste “a ojo”:</p>
<pre class="r"><code>vario.b &lt;- variog(s100, max.dist=0.6) #discretizado</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<pre class="r"><code>vario.s &lt;- variog(s100, max.dist=0.6,option = &quot;smooth&quot;, kernel = &quot;normal&quot;, band = 0.2)  #suavizado</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<pre class="r"><code>plot(vario.b)
lines(vario.s, type = &quot;l&quot;, lty = 2)

lines.variomodel(cov.model = &quot;exp&quot;, cov.pars = c(1,0.3), nugget = 0, max.dist = 0.6, lwd = 3)
legend(0.3, 0.3, c(&quot;empirico&quot;, &quot;suavizado&quot;, &quot;modelo exponencial&quot;), lty = c(1, 2, 1), lwd = c(1, 1, 3))</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-18-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Otros ajustes:</p>
<pre class="r"><code>plot(vario.b)
lines.variomodel(cov.model = &quot;exp&quot;, cov.pars = c(0.9,0.3), nug = 0.1, max.dist = 0.6)
lines.variomodel(cov.model = &quot;mat&quot;, cov.pars = c(0.85,0.2), nug = 0.1, kappa = 1, max.dist = 0.6,lty = 2)
lines.variomodel(cov.model = &quot;sph&quot;, cov.pars = c(0.8,0.8), nug = 0.1, max.dist = 0.6, lwd = 2)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-19-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Nota: no hace falta escribir el nombre completo de los parámetros (basta con que no dé lugar a confusión).</p>
<p>En las versiones recientes de <code>geoR</code> está disponible una función para realizar el ajuste gráficamente de forma interactiva (cuadro de diálogo en tcl/tk):</p>
<pre class="r"><code>eyefit(vario.b)</code></pre>
<p>Cuando se utilizan las funciones <code>variofit</code> y <code>likfit</code> para la estimación de parámetros, el efecto pepita (nugget) puede ser estimado o establecido a un valor fijo. Lo mismo ocurre con los parámetros de suavidad, anisotropía y transformación de los datos. También se dispone de opciones para incluir una tendencia. Las tendencias pueden ser polinomios en función de las coordenadas y/o funciones lineales de otras covariables.</p>
<p>Ejemplos de estimación por mínimos cuadrados (llamadas a <code>variofit</code>):</p>
<pre class="r"><code>#   Modelo exponencial con par ini umbral 1 y escala 0.5 (1/3 rango =1.5)

vario.ols &lt;- variofit(vario.b, ini = c(1, 0.5), weights = &quot;equal&quot;)  #ordinarios</code></pre>
<pre><code>   # variofit: covariance model used is matern 
   # variofit: weights used: equal 
   # variofit: minimisation function used: optim</code></pre>
<pre class="r"><code>vario.wls &lt;- variofit(vario.b, ini = c(1, 0.5), weights = &quot;cressie&quot;)  #ponderados</code></pre>
<pre><code>   # variofit: covariance model used is matern 
   # variofit: weights used: cressie 
   # variofit: minimisation function used: optim</code></pre>
<pre class="r"><code>vario.wls</code></pre>
<pre><code>   # variofit: model parameters estimated by WLS (weighted least squares):
   # covariance model is: matern with fixed kappa = 0.5 (exponential)
   # parameter estimates:
   #   tausq sigmasq     phi 
   #  0.1955  2.0110  1.4811 
   # Practical Range with cor=0.05 for asymptotic range: 4.437092
   # 
   # variofit: minimised weighted sum of squares = 31.5115</code></pre>
<pre class="r"><code>summary(vario.wls)</code></pre>
<pre><code>   # $pmethod
   # [1] &quot;WLS (weighted least squares)&quot;
   # 
   # $cov.model
   # [1] &quot;matern&quot;
   # 
   # $spatial.component
   #  sigmasq      phi 
   # 2.010972 1.481138 
   # 
   # $spatial.component.extra
   # kappa 
   #   0.5 
   # 
   # $nugget.component
   #     tausq 
   # 0.1955322 
   # 
   # $fix.nugget
   # [1] FALSE
   # 
   # $fix.kappa
   # [1] TRUE
   # 
   # $practicalRange
   # [1] 4.437092
   # 
   # $sum.of.squares
   #   value 
   # 31.5115 
   # 
   # $estimated.pars
   #     tausq   sigmasq       phi 
   # 0.1955322 2.0109718 1.4811376 
   # 
   # $weights
   # [1] &quot;cressie&quot;
   # 
   # $call
   # variofit(vario = vario.b, ini.cov.pars = c(1, 0.5), weights = &quot;cressie&quot;)
   # 
   # attr(,&quot;class&quot;)
   # [1] &quot;summary.variomodel&quot;</code></pre>
<p>Ejemplo de estimación por máxima verosimilitud (llamada a <code>likfit</code>):</p>
<pre class="r"><code>vario.ml &lt;- likfit(s100, ini = c(1, 0.5)) #Modelo exponencial con par ini umbral y escala (1/3 rango)</code></pre>
<pre><code>   # ---------------------------------------------------------------
   # likfit: likelihood maximisation using the function optim.
   # likfit: Use control() to pass additional
   #          arguments for the maximisation function.
   #         For further details see documentation for optim.
   # likfit: It is highly advisable to run this function several
   #         times with different initial values for the parameters.
   # likfit: WARNING: This step can be time demanding!
   # ---------------------------------------------------------------
   # likfit: end of numerical maximisation.</code></pre>
<pre class="r"><code>vario.ml</code></pre>
<pre><code>   # likfit: estimated model parameters:
   #     beta    tausq  sigmasq      phi 
   # &quot;0.7766&quot; &quot;0.0000&quot; &quot;0.7517&quot; &quot;0.1827&quot; 
   # Practical Range with cor=0.05 for asymptotic range: 0.547383
   # 
   # likfit: maximised log-likelihood = -83.57</code></pre>
<pre class="r"><code>summary(vario.ml)</code></pre>
<pre><code>   # Summary of the parameter estimation
   # -----------------------------------
   # Estimation method: maximum likelihood 
   # 
   # Parameters of the mean component (trend):
   #   beta 
   # 0.7766 
   # 
   # Parameters of the spatial component:
   #    correlation function: exponential
   #       (estimated) variance parameter sigmasq (partial sill) =  0.7517
   #       (estimated) cor. fct. parameter phi (range parameter)  =  0.1827
   #    anisotropy parameters:
   #       (fixed) anisotropy angle = 0  ( 0 degrees )
   #       (fixed) anisotropy ratio = 1
   # 
   # Parameter of the error component:
   #       (estimated) nugget =  0
   # 
   # Transformation parameter:
   #       (fixed) Box-Cox parameter = 1 (no transformation)
   # 
   # Practical Range with cor=0.05 for asymptotic range: 0.547383
   # 
   # Maximised Likelihood:
   #    log.L n.params      AIC      BIC 
   # &quot;-83.57&quot;      &quot;4&quot;  &quot;175.1&quot;  &quot;185.6&quot; 
   # 
   # non spatial model:
   #    log.L n.params      AIC      BIC 
   # &quot;-125.8&quot;      &quot;2&quot;  &quot;255.6&quot;  &quot;260.8&quot; 
   # 
   # Call:
   # likfit(geodata = s100, ini.cov.pars = c(1, 0.5))</code></pre>
<p>Ejemplo de estimación por máxima verosimilitud restringida (opción de <code>likfit</code>):</p>
<pre class="r"><code>vario.reml &lt;- likfit(s100, ini = c(1, 0.5), method = &quot;RML&quot;)</code></pre>
<pre><code>   # Warning in likfit(s100, ini = c(1, 0.5), method = &quot;RML&quot;): argument &quot;method&quot;
   # has changed and is now used as an argument to be passed to optim(). Use
   # &quot;lik.method&quot; to define the likelihood method</code></pre>
<pre><code>   # ---------------------------------------------------------------
   # likfit: likelihood maximisation using the function optim.
   # likfit: Use control() to pass additional
   #          arguments for the maximisation function.
   #         For further details see documentation for optim.
   # likfit: It is highly advisable to run this function several
   #         times with different initial values for the parameters.
   # likfit: WARNING: This step can be time demanding!
   # ---------------------------------------------------------------
   # likfit: end of numerical maximisation.</code></pre>
<pre class="r"><code>summary(vario.reml)</code></pre>
<pre><code>   # Summary of the parameter estimation
   # -----------------------------------
   # Estimation method: restricted maximum likelihood 
   # 
   # Parameters of the mean component (trend):
   #   beta 
   # 0.7478 
   # 
   # Parameters of the spatial component:
   #    correlation function: exponential
   #       (estimated) variance parameter sigmasq (partial sill) =  0.8473
   #       (estimated) cor. fct. parameter phi (range parameter)  =  0.2102
   #    anisotropy parameters:
   #       (fixed) anisotropy angle = 0  ( 0 degrees )
   #       (fixed) anisotropy ratio = 1
   # 
   # Parameter of the error component:
   #       (estimated) nugget =  0
   # 
   # Transformation parameter:
   #       (fixed) Box-Cox parameter = 1 (no transformation)
   # 
   # Practical Range with cor=0.05 for asymptotic range: 0.6296295
   # 
   # Maximised Likelihood:
   #    log.L n.params      AIC      BIC 
   # &quot;-81.53&quot;      &quot;4&quot;  &quot;171.1&quot;  &quot;181.5&quot; 
   # 
   # non spatial model:
   #    log.L n.params      AIC      BIC 
   # &quot;-125.1&quot;      &quot;2&quot;  &quot;254.1&quot;  &quot;259.3&quot; 
   # 
   # Call:
   # likfit(geodata = s100, ini.cov.pars = c(1, 0.5), method = &quot;RML&quot;)</code></pre>
<p><strong>NOTAS</strong>:</p>
<ul>
<li><p>Para fijar el nugget a un valor p.e. 0.15 añadir las opciones: <code>fix.nugget = TRUE, nugget = 0.15</code>.</p></li>
<li><p>Se puede tener en cuenta anisotropía geométrica en los modelos de variograma a partir de los parámetros <code>psiA</code> (ángulo, en radianes, de la dirección de mayor dependencia espacial i.e. con el máximo rango) y <code>psiR</code> (relación, mayor o igual que 1, entre los rangos máximo y mínimo). Se pueden fijar a distintos valores o estimarlos incluyendo las opciones <code>fix.psiA = FALSE</code> y <code>fix.psiR = FALSE</code> en las llamadas a las rutinas de ajuste.)</p></li>
</ul>
<p>Representación gráfica junto al estimador empírico:</p>
<pre class="r"><code>plot(vario.b, main = &quot;Estimador empírico y modelos ajustados&quot;)
lines(vario.ml, max.dist = 0.6)
lines(vario.reml, lwd = 2, max.dist = 0.6)
lines(vario.ols, lty = 2, max.dist = 0.6)
lines(vario.wls, lty = 2, lwd = 2, max.dist = 0.6)
legend(0.3, 0.3, legend = c(&quot;ML&quot;, &quot;REML&quot;, &quot;OLS&quot;, &quot;WLS&quot;), lty = c(1, 1, 2, 2), lwd = c(1, 2,1, 2)) </code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-24-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><br></p>
</div>
<div id="inferencia-sobre-el-variograma" class="section level3">
<h3>3.3 Inferencia sobre el variograma</h3>
<p>Se pueden obtener dos tipos de envolventes (envelopes, i.e. valores máximos y mínimos aproximados) del variograma empírico mediante simulación:</p>
<ul>
<li><p>Bajo la hipótesis de que no hay correlación espacial (obtenidos por permutaciones aleatorias de los datos sobre las posiciones espaciales), para estudiar si hay una dependencia espacial “significativa”.</p></li>
<li><p>Bajo un modelo de variograma, para ilustrar la variabilidad del variograma empírico.</p></li>
</ul>
<pre class="r"><code>env.indep &lt;- variog.mc.env(s100, obj.var = vario.b)</code></pre>
<pre><code>   # variog.env: generating 99 simulations by permutating data values
   # variog.env: computing the empirical variogram for the 99 simulations
   # variog.env: computing the envelops</code></pre>
<pre class="r"><code>env.model &lt;- variog.model.env(s100, obj.var = vario.b, model = vario.wls)</code></pre>
<pre><code>   # Warning in if (class(model.pars) == &quot;eyefit&quot;) {: la condición tiene
   # longitud &gt; 1 y sólo el primer elemento será usado</code></pre>
<pre><code>   # variog.env: generating 99 simulations (with  100 points each) using the function grf
   # variog.env: adding the mean or trend
   # variog.env: computing the empirical variogram for the 99 simulations
   # variog.env: computing the envelops</code></pre>
<pre class="r"><code>oldpar &lt;- par(mfrow = c(1, 2))
plot(vario.b, envelope = env.indep)
plot(vario.b, envelope = env.model)
lines(vario.wls, lty = 2, lwd = 2, max.dist = 0.6)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-25-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>par(oldpar)     </code></pre>
<p>Para estudiar si hay una dependencia espacial “significativa” se puede emplear también la rutina <code>sm.variogram</code> del paquete <code>sm</code>. Esta rutina devuelve un p-valor para contrastar la hipótesis nula de independencia (i.e. se acepta que hay una dependencia espacial si <span class="math inline">\(p \leq \alpha = 0.05\)</span>) y un gráfico en el que se muestra el estimador empírico robusto, un estimador suavizado y una región de confianza para el variograma suponiendo que el proceso es independiente (i.e. consideraríamos que hay dependencia espacial si el variograma suavizado no está contenido en esa región).</p>
<pre class="r"><code># library(sm)
# sm.variogram(s100$coords, s100$data)</code></pre>
<p><br></p>
</div>
<div id="validacion-cruzada" class="section level3">
<h3>3.4 Validación cruzada</h3>
<p>Para verificar si un modelo de variograma describe adecuadamente la dependencia espacial de los datos (p.e. comparar modelos), se emplea normalmente la técnica de validación cruzada, función <code>xvalid</code> en <code>geoR</code>. Por defecto la validación se realiza sobre los datos eliminando cada observación (y utilizando las restantes para predecir), aunque se puede utilizar un conjunto diferente de posiciones (o de datos) mediante el argumento <code>location.xvalid</code> (y <code>data.xvalid</code>).</p>
<pre class="r"><code>xv.wls &lt;- xvalid(s100, model = vario.wls)</code></pre>
<pre><code>   # xvalid: number of data locations       = 100
   # xvalid: number of validation locations = 100
   # xvalid: performing cross-validation at location ... 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 
   # xvalid: end of cross-validation</code></pre>
<pre class="r"><code>summary(xv.wls)</code></pre>
<pre><code>   #                 Min.    1st Qu.     Median         Mean   3rd Qu.     Max.
   # errors     -1.429944 -0.4017821 0.04881742 0.0008450629 0.3359677 1.319640
   # std.errors -2.110654 -0.7048560 0.07804159 0.0011568059 0.5922810 2.228054
   #                   sd
   # errors     0.5299818
   # std.errors 0.9190753</code></pre>
<pre class="r"><code>xv.reml &lt;- xvalid(s100, model = vario.reml)</code></pre>
<pre><code>   # xvalid: number of data locations       = 100
   # xvalid: number of validation locations = 100
   # xvalid: performing cross-validation at location ... 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 
   # xvalid: end of cross-validation</code></pre>
<pre class="r"><code>summary(xv.reml)</code></pre>
<pre><code>   #                 Min.    1st Qu.     Median        Mean   3rd Qu.     Max.
   # errors     -1.178020 -0.3109277 0.02326020 0.011894019 0.2631596 1.521489
   # std.errors -2.419106 -0.7304294 0.07954355 0.009241635 0.5802049 2.690047
   #                   sd
   # errors     0.4813133
   # std.errors 0.9906166</code></pre>
<p>Por defecto la función <code>plot</code> (<code>plot.xvalid</code>) muestra 10 gráficos diferentes (para más información ejecutar <code>?plot.xvalid</code>), a grosso modo los cinco primeros se corresponden con residuos simples (valores observados menos predicciones) y los segundos con residuos estandarizados (dividiendo por la raíz cuadrada de la varianza de predicción).</p>
<pre class="r"><code>oldpar &lt;- par(mfrow = c(2, 5))
plot(xv.wls, ask = FALSE)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-28-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>par(oldpar)

# plot(xv.reml)</code></pre>
<p><strong>NOTA</strong>: Para re-estimar los parámetros del modelo cada vez que se elimina una observación (i.e. validar el procedimiento de estimación) añadir la opción <code>reest = TRUE</code> (puede requerir mucho tiempo de computación). <br></p>
</div>
<div id="estimacion-del-variograma-en-procesos-no-estacionarios" class="section level3">
<h3>3.5 Estimación del variograma en procesos no estacionarios</h3>
<p>Cuando el proceso no es estacionario (no se puede emplear directamente los estimadores empíricos) hay que eliminar la tendencia para estimar el variograma:</p>
<pre class="r"><code>oldpar &lt;- par(mfrow=c(1,2)) 
plot(variog(wolfcamp, max.dist = 200)) # Supone que el proceso es estacionario</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<pre class="r"><code>plot(variog(wolfcamp, trend = ~coords, max.dist = 200)) # Asume una tendencia lineal en las coordenadas</code></pre>
<pre><code>   # variog: computing omnidirectional variogram</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-29-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>par(oldpar)</code></pre>
<p><br></p>
</div>
</div>
<div id="prediccion-espacial-kriging" class="section level2">
<h2>4. Predicción espacial (kriging)</h2>
<p>El paquete <code>geoR</code> dispone de opciones para los métodos kriging tradicionales, que dependiendo de las suposiciones acerca de la función de tendencia se clasifican en:</p>
<ul>
<li><p><em>Kriging simple</em> (<strong>KS</strong>): media conocida</p></li>
<li><p><em>Kriging ordinario</em> (<strong>KO</strong>): se supone que la media es constante y desconocida.</p></li>
<li><p><em>Kriging universal</em> (<strong>KU</strong>): también denominado kriging con modelo de tendencia, se supone que la media es una combinación lineal (desconocida) de las coordenadas o de otras variables explicativas.</p></li>
</ul>
<p>Existen también opciones adicionales para kriging trans-normal (con transformaciones Box-Cox para aproximarse a la normalidad y transformación de nuevo de resultados a la escala original manteniendo insesgadez). También admite modelos de variograma geométricamente anisotrópicos.</p>
<p>Para obtener una rejilla discreta de predicción puede ser de utilidad la función <code>expand.grid</code>:</p>
<pre class="r"><code>pred.grid &lt;- expand.grid(x = seq(0, 1, l = 51), y =  seq(0, 1, l = 51)) #rejilla regular 51x51 en cuadrado unidad
# pred.grid &lt;- expand.grid(seq(0, 1, l = 51), seq(0, 1, l = 51)) #rejilla regular 51x51 en cuadrado unidad
plot(s100$coords, pch = 20)
points(pred.grid, pch = 3, cex = 0.2)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-30-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>El comando para realizar kriging ordinario con variograma <code>vario.wls</code> sería:</p>
<pre class="r"><code>ko.wls &lt;- krige.conv(s100, loc = pred.grid, krige = krige.control(obj.m = vario.wls))</code></pre>
<pre><code>   # krige.conv: model with constant mean
   # krige.conv: Kriging performed using global neighbourhood</code></pre>
<p>El resultado es una lista incluyendo predicciones (<code>ko.wls$predict</code>) y varianzas kriging (<code>ko.wls$krige.var</code>):</p>
<pre class="r"><code>names(ko.wls)</code></pre>
<pre><code>   # [1] &quot;predict&quot;      &quot;krige.var&quot;    &quot;beta.est&quot;     &quot;distribution&quot;
   # [5] &quot;message&quot;      &quot;call&quot;</code></pre>
<p>Para ver todas las opciones de kriging disponibles ejecutar <code>?krige.control</code>. Para kriging con vecindario local (archivos de datos grandes) se puede utilizar la función <code>ksline</code>.</p>
<p>Para representar las superficies se puede utilizar la función <code>image</code>:</p>
<pre class="r"><code>oldpar &lt;- par(mfrow = c(1, 2))
image(ko.wls) #superficie de predicción
title(&quot;Predicciones&quot;)
points(s100$coords, pch=20) #añadir posiciones datos
contour(ko.wls,add=T) #añadir gráfico de contorno

image(ko.wls, val = ko.wls$krige.var) #superficie de varianzas
title(&quot;Superficie de varianzas&quot;)
points(s100$coords, pch=20)
contour(ko.wls,val=sqrt(ko.wls$krige.var),add=T)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-33-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>par(oldpar)</code></pre>
<p>Otras opciones:</p>
<pre class="r"><code>contour(ko.wls,filled = TRUE)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-34-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>persp(ko.wls, theta=-60, phi=30, col=topo.colors(10))</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-34-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>fcol &lt;- topo.colors(10)[cut(matrix(ko.wls$pred,nrow=51,ncol=51)[-1,-1],10,include.lowest=TRUE)]
persp(ko.wls, theta=-60, phi=40, col=fcol)</code></pre>
<p><img src="/post/2017-10-23-introducción-a-la-geoestadística-con-geor_files/figure-html/unnamed-chunk-34-3.png" width="672" style="display: block; margin: auto;" /></p>
<p><br></p>
<hr />
<p>Copyright 2009-2017 Rubén Fernández Casal</p>
<p>Se autoriza la realización y distribución de copias literales de este manual, siempre y cuando las advertencias del copyright y de este permiso se conserven en todas las copias.</p>
<p>Se autoriza la realización y distribución de copias modificadas de este manual, en las mismas condiciones de las copias literales, siempre y cuando la totalidad del trabajo resultante se distribuya bajo los términos de una advertencia de permiso idéntica a esta.</p>
</div>
</div>

    </div>

    
    
    
    <div class="article-tags">
      
      <a class="btn btn-primary btn-outline" href="/tags/geoestad%c3%adstica">Geoestadística</a>
      
      <a class="btn btn-primary btn-outline" href="/tags/regresion">regresion</a>
      
      <a class="btn btn-primary btn-outline" href="/tags/paquetes">Paquetes</a>
      
    </div>
    
    

  </div>

</article>



<div class="article-container article-widget">
  <div class="hr-light"></div>
  <h3></h3>
  <ul>
    
    <li><a href="/post/npsp/">Geoestadística no paramétrica con `npsp`</a></li>
    
    <li><a href="/post/diagnosis-de-la-independencia/">Diagnosis de la independencia</a></li>
    
    <li><a href="/post/2015-07-23-r-rmarkdown/">Hello R Markdown</a></li>
    
  </ul>
</div>




<div class="article-container">
  
<section id="comments">
  <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "rubenfcasal" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2017 Ruben Fernandez-Casal &middot; 

      Powered by <a href="https://bookdown.org/yihui/blogdown" target="_blank">blogdown</a> 
      and the <a href="https://github.com/gcushen/hugo-academic" target="_blank">Academic
      theme</a> for <a href="http://gohugo.io" target="_blank">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>

    

    
    
    <script id="dsq-count-scr" src="//rubenfcasal.disqus.com/count.js" async></script>
    

    
    <script async defer src="//maps.googleapis.com/maps/api/js"></script>
    

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha512-3P8rXCuGJdNZOnUx/03c1jOTnMn3rP63nBip5gOP2qmUh5YAdVAvFZ1E+QLZZbC1rtMrQb+mah3AfYW11RUrWA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.3/imagesloaded.pkgd.min.js" integrity="sha512-umsR78NN0D23AzgoZ11K7raBD+R6hqKojyBZs1w8WvYlsI+QuKRGBx3LFCwhatzBunCjDuJpDHwxD13sLMbpRA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gmaps.js/0.4.25/gmaps.min.js" integrity="sha256-7vjlAeb8OaTrCXZkCNun9djzuB2owUsaO72kXaFDBJs=" crossorigin="anonymous"></script>
    
    <script src="/js/hugo-academic.js"></script>
    

    
    
      
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
      

      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML" integrity="sha512-tOav5w1OjvsSJzePRtt2uQPFwBoHt1VZcUq8l8nm5284LEKE9FSJBQryzMBzHxY5P0zRdNqEcpLIRVYFNgu1jw==" crossorigin="anonymous"></script>
    
    

  </body>
</html>

